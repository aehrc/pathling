"use strict";(globalThis.webpackChunkpathling_site=globalThis.webpackChunkpathling_site||[]).push([[8058],{1673:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>l,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"server/caching","title":"Caching","description":"Pathling implements ETag-based cache validation, which enables clients to skip processing of queries when the underlying data has not changed.","source":"@site/versioned_docs/version-7.2.0/server/caching.md","sourceDirName":"server","slug":"/server/caching","permalink":"/docs/7.2.0/server/caching","draft":false,"unlisted":false,"editUrl":"https://github.com/aehrc/pathling/tree/main/site/versioned_docs/version-7.2.0/server/caching.md","tags":[],"version":"7.2.0","sidebarPosition":8,"frontMatter":{"sidebar_position":8,"description":"Pathling implements ETag-based cache validation, which enables clients to skip processing of queries when the underlying data has not changed."},"sidebar":"server","previous":{"title":"Async","permalink":"/docs/7.2.0/server/async"},"next":{"title":"Synchronization","permalink":"/docs/7.2.0/server/sync"}}');var i=t(4848),a=t(8453);const r={sidebar_position:8,description:"Pathling implements ETag-based cache validation, which enables clients to skip processing of queries when the underlying data has not changed."},o="Caching",h={},c=[];function d(e){const n={a:"a",code:"code",h1:"h1",header:"header",p:"p",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"caching",children:"Caching"})}),"\n",(0,i.jsxs)(n.p,{children:["Pathling implements\n",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag",children:"ETag"}),"-based\ncache validation, which enables clients to skip processing of queries when the\nunderlying data has not changed."]}),"\n",(0,i.jsxs)(n.p,{children:["To use ETags, simply take the content of the ",(0,i.jsx)(n.code,{children:"ETag"})," header that is returned with\na Pathling response. You can then accompany a subsequent request with the\n",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match",children:"If-None-Match"}),",\nusing the previously received ETag as the value. If the result of the query\nwould not have changed, Pathling will respond\nwith ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304",children:"304 Not Modified"}),",\nand will skip re-processing of the query."]}),"\n",(0,i.jsx)(n.p,{children:"Web browsers already implement this behaviour, and if your application runs in\nthe browser you will get the benefits without any extra implementation effort."}),"\n",(0,i.jsx)(n.p,{children:"The current limitation of this implementation within Pathling is that caching is\ndone over the entire database, not scoped to individual resource types. This\nmeans that updates to any resource will invalidate the cache for the entire\ndatabase."}),"\n",(0,i.jsx)(n.p,{children:"Cache keys persist across restarts of the server, as they are derived from state\nthat is persisted along with the data."})]})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(6540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);