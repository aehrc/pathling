"use strict";(globalThis.webpackChunkpathling_site=globalThis.webpackChunkpathling_site||[]).push([[2598],{1470:(e,n,a)=>{a.d(n,{A:()=>w});var r=a(6540),t=a(4164),l=a(7559),o=a(3104),i=a(6347),s=a(205),c=a(7485),u=a(1682),d=a(679);function h(e){return r.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function g(e){const{values:n,children:a}=e;return(0,r.useMemo)(()=>{const e=n??function(e){return h(e).map(({props:{value:e,label:n,attributes:a,default:r}})=>({value:e,label:n,attributes:a,default:r}))}(a);return function(e){const n=(0,u.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,a])}function p({value:e,tabValues:n}){return n.some(n=>n.value===e)}function m({queryString:e=!1,groupId:n}){const a=(0,i.W6)(),t=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(t),(0,r.useCallback)(e=>{if(!t)return;const n=new URLSearchParams(a.location.search);n.set(t,e),a.replace({...a.location,search:n.toString()})},[t,a])]}function f(e){const{defaultValue:n,queryString:a=!1,groupId:t}=e,l=g(e),[o,i]=(0,r.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const a=n.find(e=>e.default)??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:l})),[c,u]=m({queryString:a,groupId:t}),[h,f]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[a,t]=(0,d.Dv)(n);return[a,(0,r.useCallback)(e=>{n&&t.set(e)},[n,t])]}({groupId:t}),y=(()=>{const e=c??h;return p({value:e,tabValues:l})?e:null})();(0,s.A)(()=>{y&&i(y)},[y]);return{selectedValue:o,selectValue:(0,r.useCallback)(e=>{if(!p({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);i(e),u(e),f(e)},[u,f,l]),tabValues:l}}var y=a(2303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var _=a(4848);function b({className:e,block:n,selectedValue:a,selectValue:r,tabValues:l}){const i=[],{blockElementScrollPositionUntilNextRender:s}=(0,o.a_)(),c=e=>{const n=e.currentTarget,t=i.indexOf(n),o=l[t].value;o!==a&&(s(n),r(o))},u=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const a=i.indexOf(e.currentTarget)+1;n=i[a]??i[0];break}case"ArrowLeft":{const a=i.indexOf(e.currentTarget)-1;n=i[a]??i[i.length-1];break}}n?.focus()};return(0,_.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,t.A)("tabs",{"tabs--block":n},e),children:l.map(({value:e,label:n,attributes:r})=>(0,_.jsx)("li",{role:"tab",tabIndex:a===e?0:-1,"aria-selected":a===e,ref:e=>{i.push(e)},onKeyDown:u,onClick:c,...r,className:(0,t.A)("tabs__item",v.tabItem,r?.className,{"tabs__item--active":a===e}),children:n??e},e))})}function x({lazy:e,children:n,selectedValue:a}){const l=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=l.find(e=>e.props.value===a);return e?(0,r.cloneElement)(e,{className:(0,t.A)("margin-top--md",e.props.className)}):null}return(0,_.jsx)("div",{className:"margin-top--md",children:l.map((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==a}))})}function j(e){const n=f(e);return(0,_.jsxs)("div",{className:(0,t.A)(l.G.tabs.container,"tabs-container",v.tabList),children:[(0,_.jsx)(b,{...n,...e}),(0,_.jsx)(x,{...n,...e})]})}function w(e){const n=(0,y.A)();return(0,_.jsx)(j,{...e,children:h(e.children)},String(n))}},7813:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>u,default:()=>p,frontMatter:()=>c,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"libraries/examples/grouping-snomed","title":"Grouping and analysing SNOMED CT data","description":"Tutorial demonstrating how to group and analyse SNOMED CT data using Python with the Pathling library and a terminology server.","source":"@site/docs/libraries/examples/grouping-snomed.md","sourceDirName":"libraries/examples","slug":"/libraries/examples/grouping-snomed","permalink":"/docs/libraries/examples/grouping-snomed","draft":false,"unlisted":false,"editUrl":"https://github.com/aehrc/pathling/tree/main/site/docs/libraries/examples/grouping-snomed.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Grouping and analysing SNOMED CT data","description":"Tutorial demonstrating how to group and analyse SNOMED CT data using Python with the Pathling library and a terminology server."},"sidebar":"libraries","previous":{"title":"FHIR server synchronisation","permalink":"/docs/libraries/examples/fhir-server-sync"},"next":{"title":"Streaming queries","permalink":"/docs/libraries/examples/streaming"}}');var t=a(4848),l=a(8453),o=a(1470),i=a(9365);const s=a.p+"assets/images/snomed-grouped-98701f3d339ee8bb58090d5280b91e0f.png",c={sidebar_position:3,title:"Grouping and analysing SNOMED CT data",description:"Tutorial demonstrating how to group and analyse SNOMED CT data using Python with the Pathling library and a terminology server."},u="Grouping and analysing SNOMED CT data",d={},h=[{value:"Setting up the environment",id:"setting-up-the-environment",level:2},{value:"Configuring Pathling",id:"configuring-pathling",level:2},{value:"Loading and transforming data",id:"loading-and-transforming-data",level:2},{value:"Grouping with value sets",id:"grouping-with-value-sets",level:2},{value:"Handling overlapping categories",id:"handling-overlapping-categories",level:2},{value:"Creating mutually exclusive categories",id:"creating-mutually-exclusive-categories",level:2},{value:"Visualisation of mutually exclusive categories",id:"visualisation-of-mutually-exclusive-categories",level:2}];function g(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"grouping-and-analysing-snomed-ct-data",children:"Grouping and analysing SNOMED CT data"})}),"\n",(0,t.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/ahVHCWpXSPA?si=pDKHIt7_wceB270D",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",referrerpolicy:"strict-origin-when-cross-origin",allowfullscreen:!0}),"\n",(0,t.jsx)(n.p,{children:"This tutorial demonstrates how to group and analyse SNOMED CT data using\nPython with the Pathling library and a terminology server. The process involves\nsetting up a Python environment, loading and transforming data, creating value\nsets for grouping, and visualising the results."}),"\n",(0,t.jsx)(n.h2,{id:"setting-up-the-environment",children:"Setting up the environment"}),"\n",(0,t.jsxs)(n.p,{children:["The first step is to set up the environment. This\ninvolves importing the necessary libraries: ",(0,t.jsx)(n.code,{children:"pathling"})," for SNOMED data\noperations, along with data manipulation and visualisation libraries."]}),"\n",(0,t.jsxs)(o.A,{children:[(0,t.jsx)(i.A,{value:"python",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from pathling import PathlingContext\nfrom pyspark.sql.functions import col, month\nimport plotly.express as px\n"})})}),(0,t.jsx)(i.A,{value:"r",label:"R",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-r",children:"library(sparklyr)\nlibrary(pathling)\nlibrary(dplyr)\nlibrary(ggplot2)\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"configuring-pathling",children:"Configuring Pathling"}),"\n",(0,t.jsx)(n.p,{children:"A Pathling context is created and configured to use a local terminology cache.\nThis helps to speed up the analysis by reusing terminology requests."}),"\n",(0,t.jsxs)(o.A,{children:[(0,t.jsx)(i.A,{value:"python",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"pc = PathlingContext.create()\n"})})}),(0,t.jsx)(i.A,{value:"r",label:"R",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-r",children:"pc <- pathling_connect()\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"loading-and-transforming-data",children:"Loading and transforming data"}),"\n",(0,t.jsx)(n.p,{children:"The source data is loaded from a CSV file, and new columns are added for '\nArrival Month' and 'Primary Diagnosis Term' by retrieving preferred terms from\nthe terminology server."}),"\n",(0,t.jsxs)(o.A,{children:[(0,t.jsx)(i.A,{value:"python",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'source_df = pc.spark.read.csv("snomed_data.csv", header=True)\n\ntransformed_df = source_df.select(\n    col("id"),\n    month(col("arrive_at")).alias("Arrival Month"),\n    col("primary_diagnosis_concept")\n).withColumn(\n    "Primary Diagnosis Term",\n    pc.snomed.display(col("primary_diagnosis_concept"))\n)\n'})})}),(0,t.jsx)(i.A,{value:"r",label:"R",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-r",children:'source_df <- pathling_spark(pc) %>%\n        spark_read_csv("snomed_data.csv", header = TRUE)\n\ntransformed_df <- source_df %>%\n        select(\n                id,\n                "Arrival Month" = month(arrive_at),\n                primary_diagnosis_concept\n        ) %>%\n        mutate(\n                "Primary Diagnosis Term" = !!tx_display(!!tx_to_snomed_coding(primary_diagnosis_concept))\n        )\n'})})})]}),"\n",(0,t.jsx)(n.h2,{id:"grouping-with-value-sets",children:"Grouping with value sets"}),"\n",(0,t.jsx)(n.p,{children:'The core of the grouping process involves defining value sets based on SNOMED\ncodes. The video provides examples for creating value sets for "Viral\nInfection", "Musculoskeletal Injury", and "Mental Health Problem" using\nExpression Constraint Language (ECL). The Shrimp terminology browser is used to\nexplore SNOMED hierarchies and create these ECL expressions.'}),"\n",(0,t.jsxs)(o.A,{children:[(0,t.jsx)(i.A,{value:"python",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'viral_infection_ecl = "<< 64572001"  # Viral disease\nmusculoskeletal_injury_ecl = "<< 263534002"  # Injury of musculoskeletal system\nmental_health_ecl = "<< 40733004 |Mental state finding|"\n\ncategorized_df = transformed_df.withColumn(\n    "Viral Infection",\n    pc.snomed.member_of(col("primary_diagnosis_concept"), viral_infection_ecl)\n).withColumn(\n    "Musculoskeletal Injury",\n    pc.snomed.member_of(col("primary_diagnosis_concept"),\n                        musculoskeletal_injury_ecl)\n).withColumn(\n    "Mental Health Problem",\n    pc.snomed.member_of(col("primary_diagnosis_concept"), mental_health_ecl)\n)\n'})})}),(0,t.jsx)(i.A,{value:"r",label:"R",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-r",children:'viral_infection_ecl <- "<< 64572001"  # Viral disease\nmusculoskeletal_injury_ecl <- "<< 263534002"  # Injury of musculoskeletal system\nmental_health_ecl <- "<< 40733004 |Mental state finding|"\n\ncategorized_df <- transformed_df %>%\n        mutate(\n                "Viral Infection" = !!tx_member_of(\n                        !!tx_to_snomed_coding(primary_diagnosis_concept),\n                        !!tx_to_ecl_value_set(viral_infection_ecl)\n                ),\n                "Musculoskeletal Injury" = !!tx_member_of(\n                        !!tx_to_snomed_coding(primary_diagnosis_concept),\n                        !!tx_to_ecl_value_set(musculoskeletal_injury_ecl)\n                ),\n                "Mental Health Problem" = !!tx_member_of(\n                        !!tx_to_snomed_coding(primary_diagnosis_concept),\n                        !!tx_to_ecl_value_set(mental_health_ecl)\n                )\n        )\n'})})})]}),"\n",(0,t.jsx)(n.h2,{id:"handling-overlapping-categories",children:"Handling overlapping categories"}),"\n",(0,t.jsx)(n.p,{children:"Due to the nature of SNOMED's multiple parentage, some categories may overlap.\nFor instance, a condition like \"rabies coma\" can be classified as both a viral\ninfection and a mental health finding. The data is grouped by 'Arrival Month' to\ncount all encounters and then visualised to show the number of\nencounters per month for each category."}),"\n",(0,t.jsxs)(o.A,{children:[(0,t.jsx)(i.A,{value:"python",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'all_encounters_df = categorized_df.groupBy(\n    "Arrival Month").count().withColumnRenamed("count", "All Encounters")\nviral_infection_count_df = categorized_df.filter(\n    col("Viral Infection")).groupBy("Arrival Month").count().withColumnRenamed(\n    "count", "Viral Infection")\nmusculoskeletal_injury_count_df = categorized_df.filter(\n    col("Musculoskeletal Injury")).groupBy(\n    "Arrival Month").count().withColumnRenamed("count",\n                                               "Musculoskeletal Injury")\nmental_health_count_df = categorized_df.filter(\n    col("Mental Health Problem")).groupBy(\n    "Arrival Month").count().withColumnRenamed("count", "Mental Health Problem")\n\n# Code for joining these dataframes and creating a Plotly chart would follow\n'})})}),(0,t.jsx)(i.A,{value:"r",label:"R",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-r",children:'all_encounters_df <- categorized_df %>%\n        group_by(`Arrival Month`) %>%\n        summarise("All Encounters" = n(), .groups = "drop")\n\nviral_infection_count_df <- categorized_df %>%\n        filter(`Viral Infection`) %>%\n        group_by(`Arrival Month`) %>%\n        summarise("Viral Infection" = n(), .groups = "drop")\n\nmusculoskeletal_injury_count_df <- categorized_df %>%\n        filter(`Musculoskeletal Injury`) %>%\n        group_by(`Arrival Month`) %>%\n        summarise("Musculoskeletal Injury" = n(), .groups = "drop")\n\nmental_health_count_df <- categorized_df %>%\n        filter(`Mental Health Problem`) %>%\n        group_by(`Arrival Month`) %>%\n        summarise("Mental Health Problem" = n(), .groups = "drop")\n\n# Code for joining these dataframes and creating a ggplot chart would follow\n'})})})]}),"\n",(0,t.jsx)(n.h2,{id:"creating-mutually-exclusive-categories",children:"Creating mutually exclusive categories"}),"\n",(0,t.jsx)(n.p,{children:'To avoid overlapping categories, a hierarchy is created. "Viral Infection" is\nthe first category, followed by "Musculoskeletal Injury," which excludes any\ncodes already in the "Viral Infection" category. The "Mental Health Problem"\ncategory then excludes any codes already present in the previous two categories.\nAn "Other" category is also created for any remaining codes.'}),"\n",(0,t.jsxs)(o.A,{children:[(0,t.jsx)(i.A,{value:"python",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'mutually_exclusive_df = categorized_df.withColumn(\n    "Category",\n    when(col("Viral Infection"), "Viral Infection")\n    .when(~col("Viral Infection") & col("Musculoskeletal Injury"),\n          "Musculoskeletal Injury")\n    .when(~col("Viral Infection") & ~col("Musculoskeletal Injury") & col(\n        "Mental Health Problem"), "Mental Health Problem")\n    .otherwise("Other")\n)\n'})})}),(0,t.jsx)(i.A,{value:"r",label:"R",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-r",children:'mutually_exclusive_df <- categorized_df %>%\n        mutate(\n                Category = case_when(\n                        `Viral Infection` ~ "Viral Infection",\n                        !`Viral Infection` & `Musculoskeletal Injury` ~ "Musculoskeletal Injury",\n                        !`Viral Infection` &\n                                !`Musculoskeletal Injury` &\n                                `Mental Health Problem` ~ "Mental Health Problem",\n                        TRUE ~ "Other"\n                )\n        )\n'})})})]}),"\n",(0,t.jsx)(n.h2,{id:"visualisation-of-mutually-exclusive-categories",children:"Visualisation of mutually exclusive categories"}),"\n","\n",(0,t.jsx)("img",{src:s,alt:"Grouped bar chart showing mutually exclusive categories",width:"800"}),"\n",(0,t.jsx)(n.p,{children:"The mutually exclusive categories are then counted and visualised in a grouped\nbar chart, showing the proportional distribution of these categories over time."}),"\n",(0,t.jsxs)(o.A,{children:[(0,t.jsx)(i.A,{value:"python",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'mutually_exclusive_counts_df = mutually_exclusive_df.groupBy("Arrival Month",\n                                                             "Category").count()\n\nfig = px.bar(\n    mutually_exclusive_counts_df.toPandas(),\n    x="Arrival Month",\n    y="count",\n    color="Category",\n    barmode="group"\n)\nfig.show()\n'})})}),(0,t.jsx)(i.A,{value:"r",label:"R",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-r",children:'mutually_exclusive_counts_df <- mutually_exclusive_df %>%\n        group_by(`Arrival Month`, Category) %>%\n        summarise(count = n(), .groups = "drop")\n\n# Convert to local R dataframe for plotting\nplot_data <- mutually_exclusive_counts_df %>% collect()\n\n# Create grouped bar chart\nggplot(plot_data, aes(x = `Arrival Month`, y = count, fill = Category)) +\n        geom_col(position = "dodge") +\n        labs(x = "Arrival Month", y = "Count", fill = "Category") +\n        theme_minimal()\n\n# Disconnect from Pathling\npc %>% pathling_disconnect()\n'})})})]}),"\n",(0,t.jsxs)(n.p,{children:["For more detailed information on grouping SNOMED data, you can refer\nto ",(0,t.jsx)(n.a,{href:"/docs/libraries/terminology",children:"Terminology functions"}),"."]})]})}function p(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(g,{...e})}):g(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>i});var r=a(6540);const t={},l=r.createContext(t);function o(e){const n=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(l.Provider,{value:n},e.children)}},9365:(e,n,a)=>{a.d(n,{A:()=>o});a(6540);var r=a(4164);const t={tabItem:"tabItem_Ymn6"};var l=a(4848);function o({children:e,hidden:n,className:a}){return(0,l.jsx)("div",{role:"tabpanel",className:(0,r.A)(t.tabItem,a),hidden:n,children:e})}}}]);