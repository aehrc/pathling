"use strict";(globalThis.webpackChunkpathling_site=globalThis.webpackChunkpathling_site||[]).push([[5500],{760:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>h,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"server/caching","title":"Caching","description":"Pathling implements ETag-based cache validation, which enables clients to skip processing of queries when the underlying data has not changed.","source":"@site/docs/server/caching.md","sourceDirName":"server","slug":"/server/caching","permalink":"/docs/server/caching","draft":false,"unlisted":false,"editUrl":"https://github.com/aehrc/pathling/tree/main/site/docs/server/caching.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"description":"Pathling implements ETag-based cache validation, which enables clients to skip processing of queries when the underlying data has not changed."},"sidebar":"server","previous":{"title":"Admin UI","permalink":"/docs/server/admin-ui"},"next":{"title":"Configuration","permalink":"/docs/server/configuration"}}');var t=s(4848),a=s(8453);const r={sidebar_position:6,description:"Pathling implements ETag-based cache validation, which enables clients to skip processing of queries when the underlying data has not changed."},c="Caching",h={},o=[{value:"Intermediate caching",id:"intermediate-caching",level:2},{value:"Asynchronous endpoint caching",id:"asynchronous-endpoint-caching",level:2},{value:"How async operations determine request equivalence",id:"how-async-operations-determine-request-equivalence",level:3},{value:"Server restart handling",id:"server-restart-handling",level:3},{value:"Configuring cache duration",id:"configuring-cache-duration",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"caching",children:"Caching"})}),"\n",(0,t.jsxs)(n.p,{children:["Pathling implements\n",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag",children:"ETag"}),"-based\ncache validation, which enables clients to skip processing of queries when the\nunderlying data has not changed."]}),"\n",(0,t.jsxs)(n.p,{children:["To use ETags, simply take the content of the ",(0,t.jsx)(n.code,{children:"ETag"})," header that is returned with\na Pathling response. You can then accompany a subsequent request with the\n",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match",children:"If-None-Match"}),",\nusing the previously received ETag as the value. If the result of the query\nwould not have changed, Pathling will respond\nwith ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304",children:"304 Not Modified"}),",\nand will skip re-processing of the query."]}),"\n",(0,t.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant Client\n    participant Cache\n    participant Pathling\n\n    Client->>Cache: Request\n    Cache->>Pathling: Forward request\n    Pathling->>Cache: 200 OK + ETag: "abc123"\n    Note over Cache: Store response\n    Cache->>Client: 200 OK + ETag: "abc123"\n\n    Client->>Cache: Request + If-None-Match: "abc123"\n    Cache->>Pathling: Validate ETag\n    alt Data unchanged\n        Pathling->>Cache: 304 Not Modified\n        Cache->>Client: 304 Not Modified\n    else Data changed\n        Pathling->>Cache: 200 OK + ETag: "def456"\n        Note over Cache: Update stored response\n        Cache->>Client: 200 OK + ETag: "def456"\n    end'}),"\n",(0,t.jsx)(n.p,{children:"Web browsers already implement this behaviour, and if your application runs in\nthe browser you will get the benefits without any extra implementation effort."}),"\n",(0,t.jsx)(n.p,{children:"The current limitation of this implementation within Pathling is that caching is\ndone over the entire database, not scoped to individual resource types. This\nmeans that updates to any resource will invalidate the cache for the entire\ndatabase."}),"\n",(0,t.jsx)(n.p,{children:"Cache keys persist across restarts of the server, as they are derived from state\nthat is persisted along with the data."}),"\n",(0,t.jsx)(n.h2,{id:"intermediate-caching",children:"Intermediate caching"}),"\n",(0,t.jsxs)(n.p,{children:["For production deployments, an intermediate HTTP cache can significantly improve\nperformance by storing responses closer to clients and reducing load on the\nPathling server. Pathling provides a ready-to-use\n",(0,t.jsx)(n.a,{href:"https://varnish-cache.org/",children:"Varnish"})," configuration in the\n",(0,t.jsx)(n.a,{href:"https://github.com/aehrc/pathling/tree/main/deployment/cache",children:"deployment/cache"}),"\ndirectory."]}),"\n",(0,t.jsx)(n.p,{children:"The Varnish configuration:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Forwards requests to the Pathling backend"}),"\n",(0,t.jsxs)(n.li,{children:["Respects ",(0,t.jsx)(n.code,{children:"Cache-Control"})," headers (passes through ",(0,t.jsx)(n.code,{children:"no-cache"}),", ",(0,t.jsx)(n.code,{children:"no-store"}),", and\n",(0,t.jsx)(n.code,{children:"private"})," responses)"]}),"\n",(0,t.jsx)(n.li,{children:"Stores cacheable responses with ETag-based revalidation"}),"\n",(0,t.jsx)(n.li,{children:"Compresses responses with gzip"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"To use it, set the following environment variables:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"PATHLING_HOST"}),": The hostname of the Pathling server"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"PATHLING_PORT"}),": The port number exposed by the Pathling server"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"A Helm chart is also provided for Kubernetes deployments."}),"\n",(0,t.jsx)(n.h2,{id:"asynchronous-endpoint-caching",children:"Asynchronous endpoint caching"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"$job"})," and ",(0,t.jsx)(n.code,{children:"$result"})," endpoints use a different caching strategy from other\nPathling endpoints. Instead of ETag-based revalidation, these endpoints use\nsimple TTL-based caching with ",(0,t.jsx)(n.code,{children:"Cache-Control: max-age=X"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"This approach ensures that:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Polling the ",(0,t.jsx)(n.code,{children:"$job"})," endpoint returns fresh job status without stale cached\nresponses from previous jobs"]}),"\n",(0,t.jsxs)(n.li,{children:["Download URLs from ",(0,t.jsx)(n.code,{children:"$result"})," remain cacheable for an appropriate duration"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"how-async-operations-determine-request-equivalence",children:"How async operations determine request equivalence"}),"\n",(0,t.jsxs)(n.p,{children:["When an async operation (such as ",(0,t.jsx)(n.code,{children:"$export"}),") is initiated, Pathling constructs a\ncache key from the following components:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Request URL"})," - The complete URL including all query parameters"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Salient headers"})," - Headers from the ",(0,t.jsx)(n.code,{children:"Vary"})," list, excluding those in\n",(0,t.jsx)(n.code,{children:"pathling.async.varyHeadersExcludedFromCacheKey"})," (default: ",(0,t.jsx)(n.code,{children:"Accept"}),",\n",(0,t.jsx)(n.code,{children:"Accept-Encoding"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Database state"})," - A hash of the current database state"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Operation-specific parameters"})," - For operations that support POST with a\nrequest body, parameters from the body are included"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If two requests produce the same cache key, they are considered equivalent and\nwill share the same async job. This allows multiple clients making identical\nrequests to receive results from the same job, improving efficiency."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"varyHeadersExcludedFromCacheKey"})," setting allows you to exclude headers that\ndon't affect the result (like ",(0,t.jsx)(n.code,{children:"Accept-Encoding"}),") from the cache key, so that\nrequests differing only in these headers will still share jobs."]}),"\n",(0,t.jsx)(n.h3,{id:"server-restart-handling",children:"Server restart handling"}),"\n",(0,t.jsx)(n.p,{children:"Async jobs are stored in memory and are lost when the server restarts. To\nprevent clients from polling stale job IDs from cached 202 responses, Pathling\nincludes a server instance identifier in the ETag of async responses."}),"\n",(0,t.jsx)(n.p,{children:"Each server instance generates a unique ID at startup. The 202 Accepted response\nfor an async operation includes an ETag with a compact format:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'W/"~{instanceId}.{hash}"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"~"})," prefix identifies async ETags, ",(0,t.jsx)(n.code,{children:"{instanceId}"})," is the 8-character server\ninstance ID, and ",(0,t.jsx)(n.code,{children:"{hash}"})," is an 8-character truncated SHA-256 hash of the job\nID. This format keeps ETags short while avoiding exposure of the full job UUID."]}),"\n",(0,t.jsx)(n.p,{children:"When the server restarts:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"A new instance ID is generated"}),"\n",(0,t.jsxs)(n.li,{children:["Clients with cached 202 responses send ",(0,t.jsx)(n.code,{children:"If-None-Match"})," with the old ETag"]}),"\n",(0,t.jsx)(n.li,{children:"The server detects the mismatched instance ID and returns a fresh response\nwith a new job ID, rather than 304 Not Modified"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This ensures clients always receive valid job IDs, even when using cached\nresponses from before a server restart."}),"\n",(0,t.jsx)(n.h3,{id:"configuring-cache-duration",children:"Configuring cache duration"}),"\n",(0,t.jsxs)(n.p,{children:["The cache duration is controlled by ",(0,t.jsx)(n.code,{children:"pathling.async.cacheMaxAge"})," (default: 1\nsecond). This value should be aligned with your job file retention strategy:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"S3 lifecycle policies"}),": If you configure S3 to delete job files after 24\nhours, set ",(0,t.jsx)(n.code,{children:"cacheMaxAge"})," to ",(0,t.jsx)(n.code,{children:"86400"})," (24 hours) or less"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Manual cleanup"}),": Match the cache duration to your cleanup schedule"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"No cleanup"}),": Use a longer duration to maximise cache efficiency"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Example configuration for 24-hour retention:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"pathling:\n    async:\n        cacheMaxAge: 86400\n"})}),"\n",(0,t.jsx)(n.p,{children:"When using an intermediate cache like Varnish, the cache will serve responses\nuntil the TTL expires, then fetch fresh responses from Pathling. This avoids\nthe revalidation issues that can occur with ETag-based caching for async\noperations."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var i=s(6540);const t={},a=i.createContext(t);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);